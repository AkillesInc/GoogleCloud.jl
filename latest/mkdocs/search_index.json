{
    "docs": [
        {
            "location": "/", 
            "text": "Google Cloud APIs for Julia\n\n\nThis module wraps Google Cloud Platform (GCP) APIs with Julia.\n\n\nCurrently only the Google Storage API has been added.\n\n\n\n\nQuick Start\n\n\nThis Quick Start walks through the steps required to store and retrieve data from Google Cloud Storage.\n\n\n\n\nGoogle Cloud Prerequisites\n\n\n\n\nIf you don't already have a Google account, create one \nhere\n.\n\n\nSign in to the GCP console \nhere\n.\n\n\n\n\nCreate a new project by clicking on the \nProject\n drop-down menu at the top of the page. If you already have a GCP project, click on the drop-down menu at the top of the page and select \nCreate project\n.\n\n\nA GCP project is a set of resources with common settings that is billed and  managed separately from any resource outside the set. Thus a resource  exists in exactly one project. Examples of resources include GCE instances,  storage volumes and data on those volumes. A project's settings include  ownership, users and their permissions, and associated GCP services. As a  user anything you do on GCP happens within a project, including data  storage, compute, messaging, logging, etc.\n\n\n\n\n\n\nAssociated with your project are credentials that allow users to add, read and remove resources from the project. Get the credentials for your project as a JSON file from your \nGCP Credentials\n page:\n\n\n\n\nType \ncredentials\n into the search bar at the top of the console.\n\n\nSelect \nCredentials API Manager\n from the search results.\n\n\nClick on the \nCreate credentials\n drop-down menu and select \nService account key\n.\n\n\nFrom the \nService Account\n menu select \nNew service account\n.\n\n\nFrom \nRole\n select \nStorage \n Storage Admin\n.\n\n\nEnsure the key type is JSON.\n\n\nClick \nCreate\n.\n\n\n\n\nCredentials are then automatically downloaded in a JSON file. Save this file to your machine. In this tutorial we save the service account credentials to \n~/credentials.json\n.\n\n\n\n\n\n\n\n\nInteracting with the Storage API from Julia\n\n\nStart Julia and install the \nGoogleCloud.jl\n package:\n\n\nPkg.add(\nGoogleCloud\n)\nusing GoogleCloud\n\n\n\n\nLoad the service account credentials obtained from Google:\n\n\ncreds = GoogleCredentials(expanduser(\n~/credentials.json\n))\n\n\n\n\nNow, create a session with the credentials, requesting any required scopes:\n\n\nsession = GoogleSession(creds, [\ndevstorage.full_control\n])\n\n\n\n\nSet the default session of an API using \nset_session!\n:\n\n\nset_session!(storage, session)    # storage is the API root, exported from GoogleCloud.jl\n\n\n\n\nList all existing buckets in your project. The list contains a default bucket:\n\n\nbkts = storage(:Bucket, :list)    # storage(:Bucket, :list; raw=true) returns addition information\n\n# Pretty print\nfor item in bkts\n    display(item)\n    println()\nend\n\n\n\n\nCreate a bucket called \na12345foo\n, for example. \nNote\n: The bucket name must be unique... across all buckets in GCP, so choose your own!\n\n\nstorage(:Bucket, :insert; data=Dict(:name =\n \na12345foo\n))\n\n# Verify the new bucket exists in the project\nbkts = storage(:Bucket, :list)\nfor item in bkts\n    display(item)\n    println()\nend\n\n\n\n\nList all objects in the \na12345foo\n bucket. The list is currently empty:\n\n\nstorage(:Object, :list, \na12345foo\n)\n\n\n\n\nUpload an object to the \na12345foo\n bucket:\n\n\n# String containing the contents of test_image.jpg. The semi-colon avoids an error caused by printing the returned value.\nfile_contents = readstring(open(\ntest_image.jpg\n, \nr\n));\n\n# Upload\nstorage(:Object, :insert, \na12345foo\n;     # Returns metadata about the object\n    name=\nimage.jpg\n,           # Object name is \nimage.jpg\n\n    data=file_contents,         # The data being stored on your project\n    content_type=\nimage/jpeg\n   # The contents are specified to be in JPEG format\n)\n\n# Verify that the object is in the bucket\nobs = storage(:Object, :list, \na12345foo\n)    # Ugly print\nmap(x -\n x[:name], obs)                       # Pretty print\n\n\n\n\nGet the \nimage.jpg\n object from the bucket:\n\n\ns = storage(:Object, :get, \na12345foo\n, \nimage.jpg\n);\ns == file_contents    # Verify that the retrieved data is the same as that originally posted\n\n\n\n\nDelete the \nimage.jpg\n object from the bucket:\n\n\nstorage(:Object, :delete, \na12345foo\n, \nimage.jpg\n)\n\n# Verify that the bucket is now empty\nstorage(:Object, :list, \na12345foo\n)\n\n\n\n\nDelete the bucket:\n\n\nstorage(:Bucket, :delete, \na12345foo\n)\n\n# Verify that the bucket has been deleted\nbkts = storage(:Bucket, :list)\nfor item in bkts\n    display(item)\n    println()\nend\n\n\n\n\n\n\nHigh-Level API\n\n\n\n\nCustom APIs\n\n\nCollections\n\n\n\n\n\n\n\n\n\n\nLow-Level API\n\n\n\n\nGoogle Cloud Platform Credentials\n\n\nGoogle API Authorisation Manager\n\n\nGoogle JSON APIs\n\n\nImplemented APIs\n\n\n\n\n\n\nGoogle API URLs\n\n\nError Types\n\n\n\n\n\n\nIndex\n\n\n\n\nGoogleCloud.api\n\n\nGoogleCloud.api._compute\n\n\nGoogleCloud.api._storage\n\n\nGoogleCloud.credentials\n\n\nGoogleCloud.error\n\n\nGoogleCloud.root\n\n\nGoogleCloud.session\n\n\nGoogleCloud.api._compute.compute\n\n\nGoogleCloud.api._storage.storage\n\n\nGoogleCloud.api.APIMethod\n\n\nGoogleCloud.api.APIResource\n\n\nGoogleCloud.api.APIRoot\n\n\nGoogleCloud.collection.KeyStore\n\n\nGoogleCloud.credentials.GoogleCredentials\n\n\nGoogleCloud.credentials.GoogleCredentials\n\n\nGoogleCloud.credentials.GoogleCredentials\n\n\nGoogleCloud.error.APIError\n\n\nGoogleCloud.error.CredentialError\n\n\nGoogleCloud.error.Error\n\n\nGoogleCloud.error.SessionError\n\n\nGoogleCloud.session.GoogleSession\n\n\nGoogleCloud.session.JWTClaimSet\n\n\nGoogleCloud.session.JWTHeader\n\n\nGoogleCloud.api.execute\n\n\nGoogleCloud.api.get_session\n\n\nGoogleCloud.api.iserror\n\n\nGoogleCloud.api.path_replace\n\n\nGoogleCloud.api.path_tokens\n\n\nGoogleCloud.api.set_session!\n\n\nGoogleCloud.collection.fast_forward\n\n\nGoogleCloud.root.isurl\n\n\nGoogleCloud.session.JWS\n\n\nGoogleCloud.session.SHA256withRSA\n\n\nGoogleCloud.session.authorize\n\n\nGoogleCloud.session.unixseconds", 
            "title": "Home"
        }, 
        {
            "location": "/#google-cloud-apis-for-julia", 
            "text": "This module wraps Google Cloud Platform (GCP) APIs with Julia.  Currently only the Google Storage API has been added.", 
            "title": "Google Cloud APIs for Julia"
        }, 
        {
            "location": "/#quick-start", 
            "text": "This Quick Start walks through the steps required to store and retrieve data from Google Cloud Storage.", 
            "title": "Quick Start"
        }, 
        {
            "location": "/#google-cloud-prerequisites", 
            "text": "If you don't already have a Google account, create one  here .  Sign in to the GCP console  here .   Create a new project by clicking on the  Project  drop-down menu at the top of the page. If you already have a GCP project, click on the drop-down menu at the top of the page and select  Create project .  A GCP project is a set of resources with common settings that is billed and  managed separately from any resource outside the set. Thus a resource  exists in exactly one project. Examples of resources include GCE instances,  storage volumes and data on those volumes. A project's settings include  ownership, users and their permissions, and associated GCP services. As a  user anything you do on GCP happens within a project, including data  storage, compute, messaging, logging, etc.    Associated with your project are credentials that allow users to add, read and remove resources from the project. Get the credentials for your project as a JSON file from your  GCP Credentials  page:   Type  credentials  into the search bar at the top of the console.  Select  Credentials API Manager  from the search results.  Click on the  Create credentials  drop-down menu and select  Service account key .  From the  Service Account  menu select  New service account .  From  Role  select  Storage   Storage Admin .  Ensure the key type is JSON.  Click  Create .   Credentials are then automatically downloaded in a JSON file. Save this file to your machine. In this tutorial we save the service account credentials to  ~/credentials.json .", 
            "title": "Google Cloud Prerequisites"
        }, 
        {
            "location": "/#interacting-with-the-storage-api-from-julia", 
            "text": "Start Julia and install the  GoogleCloud.jl  package:  Pkg.add( GoogleCloud )\nusing GoogleCloud  Load the service account credentials obtained from Google:  creds = GoogleCredentials(expanduser( ~/credentials.json ))  Now, create a session with the credentials, requesting any required scopes:  session = GoogleSession(creds, [ devstorage.full_control ])  Set the default session of an API using  set_session! :  set_session!(storage, session)    # storage is the API root, exported from GoogleCloud.jl  List all existing buckets in your project. The list contains a default bucket:  bkts = storage(:Bucket, :list)    # storage(:Bucket, :list; raw=true) returns addition information\n\n# Pretty print\nfor item in bkts\n    display(item)\n    println()\nend  Create a bucket called  a12345foo , for example.  Note : The bucket name must be unique... across all buckets in GCP, so choose your own!  storage(:Bucket, :insert; data=Dict(:name =   a12345foo ))\n\n# Verify the new bucket exists in the project\nbkts = storage(:Bucket, :list)\nfor item in bkts\n    display(item)\n    println()\nend  List all objects in the  a12345foo  bucket. The list is currently empty:  storage(:Object, :list,  a12345foo )  Upload an object to the  a12345foo  bucket:  # String containing the contents of test_image.jpg. The semi-colon avoids an error caused by printing the returned value.\nfile_contents = readstring(open( test_image.jpg ,  r ));\n\n# Upload\nstorage(:Object, :insert,  a12345foo ;     # Returns metadata about the object\n    name= image.jpg ,           # Object name is  image.jpg \n    data=file_contents,         # The data being stored on your project\n    content_type= image/jpeg    # The contents are specified to be in JPEG format\n)\n\n# Verify that the object is in the bucket\nobs = storage(:Object, :list,  a12345foo )    # Ugly print\nmap(x -  x[:name], obs)                       # Pretty print  Get the  image.jpg  object from the bucket:  s = storage(:Object, :get,  a12345foo ,  image.jpg );\ns == file_contents    # Verify that the retrieved data is the same as that originally posted  Delete the  image.jpg  object from the bucket:  storage(:Object, :delete,  a12345foo ,  image.jpg )\n\n# Verify that the bucket is now empty\nstorage(:Object, :list,  a12345foo )  Delete the bucket:  storage(:Bucket, :delete,  a12345foo )\n\n# Verify that the bucket has been deleted\nbkts = storage(:Bucket, :list)\nfor item in bkts\n    display(item)\n    println()\nend", 
            "title": "Interacting with the Storage API from Julia"
        }, 
        {
            "location": "/#high-level-api", 
            "text": "Custom APIs  Collections", 
            "title": "High-Level API"
        }, 
        {
            "location": "/#low-level-api", 
            "text": "Google Cloud Platform Credentials  Google API Authorisation Manager  Google JSON APIs  Implemented APIs    Google API URLs  Error Types", 
            "title": "Low-Level API"
        }, 
        {
            "location": "/#index", 
            "text": "GoogleCloud.api  GoogleCloud.api._compute  GoogleCloud.api._storage  GoogleCloud.credentials  GoogleCloud.error  GoogleCloud.root  GoogleCloud.session  GoogleCloud.api._compute.compute  GoogleCloud.api._storage.storage  GoogleCloud.api.APIMethod  GoogleCloud.api.APIResource  GoogleCloud.api.APIRoot  GoogleCloud.collection.KeyStore  GoogleCloud.credentials.GoogleCredentials  GoogleCloud.credentials.GoogleCredentials  GoogleCloud.credentials.GoogleCredentials  GoogleCloud.error.APIError  GoogleCloud.error.CredentialError  GoogleCloud.error.Error  GoogleCloud.error.SessionError  GoogleCloud.session.GoogleSession  GoogleCloud.session.JWTClaimSet  GoogleCloud.session.JWTHeader  GoogleCloud.api.execute  GoogleCloud.api.get_session  GoogleCloud.api.iserror  GoogleCloud.api.path_replace  GoogleCloud.api.path_tokens  GoogleCloud.api.set_session!  GoogleCloud.collection.fast_forward  GoogleCloud.root.isurl  GoogleCloud.session.JWS  GoogleCloud.session.SHA256withRSA  GoogleCloud.session.authorize  GoogleCloud.session.unixseconds", 
            "title": "Index"
        }, 
        {
            "location": "/custom_api/", 
            "text": "Custom APIs\n\n\n\n\nCollections\n\n\n\n\nKey-Value Store\n\n\n\n\n#\n\n\nGoogleCloud.collection.KeyStore\n \n \nType\n.\n\n\nHigh-level container wrapping a Google Storage bucket\n\n\nsource\n\n\n#\n\n\nGoogleCloud.collection.fast_forward\n \n \nMethod\n.\n\n\nSkip over missing keys if any deleted since key list was geenrated\n\n\nsource", 
            "title": "Collections"
        }, 
        {
            "location": "/custom_api/#custom-apis", 
            "text": "", 
            "title": "Custom APIs"
        }, 
        {
            "location": "/custom_api/#collections", 
            "text": "Key-Value Store   #  GoogleCloud.collection.KeyStore     Type .  High-level container wrapping a Google Storage bucket  source  #  GoogleCloud.collection.fast_forward     Method .  Skip over missing keys if any deleted since key list was geenrated  source", 
            "title": "Collections"
        }, 
        {
            "location": "/custom_api/keystore/", 
            "text": "Key-Value Store\n\n\nThe \nKeyStore\n API is a custom key-value API built on the object storage API. That is, it is not an API offered by the Google Cloud Platform. It is intended to be used to store key-value pairs. Below is a brief tutorial that walks through some typical usage of the \nKeyStore\n API.\n\n\nFirst, load the package.\n\n\nusing GoogleCloud\nsession = GoogleSession(expanduser(\n~/credentials.json\n), [\ndevstorage.full_control\n])\n\n\n\n\nDefine a function for serializing data to Vector{UInt8} before writing to the key-value store. Also define a corresponding deserializer, which is called when reading from the store. \n\n\nfunction serialize_to_uint8_vector(x)\n    io = IOBuffer()\n    serialize(io, x)\n    takebuf_array(io)\nend\n\ndeserialize_from_vector(x) = deserialize(IOBuffer(x))\n\n\n\n\nInitialize the key-value store. In this case our store uses the default options, which synchronizes the data in the remote store with the data in the local store.\n\n\nkv_sync = KeyStore{Int, Int}(\n    \nkvtest\n;                                  # Key-value store name. Created if it doesn't already exist.\n    session    = session,\n    val_writer = serialize_to_uint8_vector,    # Function for serializing data before writing to the store\n    val_reader = deserialize_from_vector,      # Function for deserializing data before reading from the store \n    use_remote = true,                         # Defaults to true. Commit every write to the remote store.\n    use_cache  = true,                         # Defaults to true. Commit every write to the local store.\n    reset      = false                         # Defaults to false. Empty the bucket if it exists.\n)\n\n\n\n\nNote that \nuse_remote\n and \nuse_cache\n can't both be \nfalse\n. An error is raised if this occurs.\n\n\nRun some basic get/set methods, verifying their effects along the way.\n\n\n# Get the data from the key-value store. Currently there is no data.\nkeys(kv_sync)       # Returns array of keys\nvalues(kv_sync)     # Returns array of values\ncollect(kv_sync)    # Returns array of Pair(key, value)\n\n# Write key-value pairs both locally (determined by use_cache = true) and remotely (determined by use_remote = true)\nkv_sync[1] = 11\nkv_sync[2] = 22\n\n# Verify local store\nkv_sync.cache\n\n# Verify remote store\nclearcache!(kv_sync)    # Clear local store\nkv_sync.cache           # Verify local store is empty again\ncollect(kv_sync)        # Pull data from remote store and populate local store\nkv_sync.cache           # Local store now contains our data\n\n\n\n\nIf you are writing frequently then the latency of persisting each write to the remote store may be unacceptably slow. One solution is to do all your writes locally, then persist them remotely with one \ncommit\n, as follows:\n\n\nkv_local = KeyStore{Int, Int}(\n    \nkvtest\n;                                  # The store name is the same as before.\n    session    = session,                      # As before\n    val_writer = serialize_to_uint8_vector,    # As before\n    val_reader = deserialize_from_vector,      # As before\n    use_remote = false                         # Work locally only, then manually sync with the remote store.\n)\n\nkv_local.cache        # Empty because kv_local is not synchronized with the remote store (because use_remote is false)\ncollect(kv_local)     # Empty because use_remote is false, so collect(kv_local) only looks at kv_local.cache\nfetch!(kv_local)      # Manually fetch the data in the remote store\ncollect(kv_local)     # Local store is now populated\nkv_local[3] = 33      # Writes to local store only\nkv_sync[3]            # Error because key 3 hasn't been committed from kv_local to remote store\nkv_local.pending      # List of changes made locally that have not been committed to the remote store\ncommit!(kv_local)     # Commit the local changes to the remote store\nkv_local.pending      # The list of pending changes is now empty\nkv_sync[3]            # Now returns 33 from the remote store\n\n\n\n\nFinally we clean up.\n\n\ndelete!(kv_sync)      # Error: Can't delete a non-empty remote store\nreset!(kv_sync)       # Remove all data from remote store. Alternatively, delete!(kv_sync, 1), delete!(kv_sync, 2), etc.\ndelete!(kv_sync)      # Detaches local store from remote store and deletes remote store\n\n\n\n\nAdditional methods include:\n\n\nclearpending!(kvstore)    # Empty the list of local changes that haven't been committed to the remote store\nsync!(kvstore)            # Commit local changes to remote store, then fetch data from remote store", 
            "title": "Key Store"
        }, 
        {
            "location": "/custom_api/keystore/#key-value-store", 
            "text": "The  KeyStore  API is a custom key-value API built on the object storage API. That is, it is not an API offered by the Google Cloud Platform. It is intended to be used to store key-value pairs. Below is a brief tutorial that walks through some typical usage of the  KeyStore  API.  First, load the package.  using GoogleCloud\nsession = GoogleSession(expanduser( ~/credentials.json ), [ devstorage.full_control ])  Define a function for serializing data to Vector{UInt8} before writing to the key-value store. Also define a corresponding deserializer, which is called when reading from the store.   function serialize_to_uint8_vector(x)\n    io = IOBuffer()\n    serialize(io, x)\n    takebuf_array(io)\nend\n\ndeserialize_from_vector(x) = deserialize(IOBuffer(x))  Initialize the key-value store. In this case our store uses the default options, which synchronizes the data in the remote store with the data in the local store.  kv_sync = KeyStore{Int, Int}(\n     kvtest ;                                  # Key-value store name. Created if it doesn't already exist.\n    session    = session,\n    val_writer = serialize_to_uint8_vector,    # Function for serializing data before writing to the store\n    val_reader = deserialize_from_vector,      # Function for deserializing data before reading from the store \n    use_remote = true,                         # Defaults to true. Commit every write to the remote store.\n    use_cache  = true,                         # Defaults to true. Commit every write to the local store.\n    reset      = false                         # Defaults to false. Empty the bucket if it exists.\n)  Note that  use_remote  and  use_cache  can't both be  false . An error is raised if this occurs.  Run some basic get/set methods, verifying their effects along the way.  # Get the data from the key-value store. Currently there is no data.\nkeys(kv_sync)       # Returns array of keys\nvalues(kv_sync)     # Returns array of values\ncollect(kv_sync)    # Returns array of Pair(key, value)\n\n# Write key-value pairs both locally (determined by use_cache = true) and remotely (determined by use_remote = true)\nkv_sync[1] = 11\nkv_sync[2] = 22\n\n# Verify local store\nkv_sync.cache\n\n# Verify remote store\nclearcache!(kv_sync)    # Clear local store\nkv_sync.cache           # Verify local store is empty again\ncollect(kv_sync)        # Pull data from remote store and populate local store\nkv_sync.cache           # Local store now contains our data  If you are writing frequently then the latency of persisting each write to the remote store may be unacceptably slow. One solution is to do all your writes locally, then persist them remotely with one  commit , as follows:  kv_local = KeyStore{Int, Int}(\n     kvtest ;                                  # The store name is the same as before.\n    session    = session,                      # As before\n    val_writer = serialize_to_uint8_vector,    # As before\n    val_reader = deserialize_from_vector,      # As before\n    use_remote = false                         # Work locally only, then manually sync with the remote store.\n)\n\nkv_local.cache        # Empty because kv_local is not synchronized with the remote store (because use_remote is false)\ncollect(kv_local)     # Empty because use_remote is false, so collect(kv_local) only looks at kv_local.cache\nfetch!(kv_local)      # Manually fetch the data in the remote store\ncollect(kv_local)     # Local store is now populated\nkv_local[3] = 33      # Writes to local store only\nkv_sync[3]            # Error because key 3 hasn't been committed from kv_local to remote store\nkv_local.pending      # List of changes made locally that have not been committed to the remote store\ncommit!(kv_local)     # Commit the local changes to the remote store\nkv_local.pending      # The list of pending changes is now empty\nkv_sync[3]            # Now returns 33 from the remote store  Finally we clean up.  delete!(kv_sync)      # Error: Can't delete a non-empty remote store\nreset!(kv_sync)       # Remove all data from remote store. Alternatively, delete!(kv_sync, 1), delete!(kv_sync, 2), etc.\ndelete!(kv_sync)      # Detaches local store from remote store and deletes remote store  Additional methods include:  clearpending!(kvstore)    # Empty the list of local changes that haven't been committed to the remote store\nsync!(kvstore)            # Commit local changes to remote store, then fetch data from remote store", 
            "title": "Key-Value Store"
        }, 
        {
            "location": "/api/credentials/", 
            "text": "Google Cloud Platform Credentials\n\n\n#\n\n\nGoogleCloud.credentials\n \n \nModule\n.\n\n\nGoogle Cloud Platform service-account API credentials.\n\n\nsource\n\n\n#\n\n\nGoogleCloud.credentials.GoogleCredentials\n \n \nType\n.\n\n\nGoogleCredentials(...)\n\n\n\n\nParse JSON credentials created for a service-account at \nGoogle Cloud Platform Console\n\n\nsource\n\n\n#\n\n\nGoogleCloud.credentials.GoogleCredentials\n \n \nMethod\n.\n\n\nGoogleCredentials(filename)\n\n\n\n\nLoad credentials from a JSON file.\n\n\nsource\n\n\n#\n\n\nGoogleCloud.credentials.GoogleCredentials\n \n \nMethod\n.\n\n\nGoogleCredentials(data::Dict{Symbol, String})\n\n\n\n\nInitialise credentials from dictionary containing values.\n\n\nsource", 
            "title": "Credentials"
        }, 
        {
            "location": "/api/credentials/#google-cloud-platform-credentials", 
            "text": "#  GoogleCloud.credentials     Module .  Google Cloud Platform service-account API credentials.  source  #  GoogleCloud.credentials.GoogleCredentials     Type .  GoogleCredentials(...)  Parse JSON credentials created for a service-account at  Google Cloud Platform Console  source  #  GoogleCloud.credentials.GoogleCredentials     Method .  GoogleCredentials(filename)  Load credentials from a JSON file.  source  #  GoogleCloud.credentials.GoogleCredentials     Method .  GoogleCredentials(data::Dict{Symbol, String})  Initialise credentials from dictionary containing values.  source", 
            "title": "Google Cloud Platform Credentials"
        }, 
        {
            "location": "/api/session/", 
            "text": "Google API Authorisation Manager\n\n\n#\n\n\nGoogleCloud.session\n \n \nModule\n.\n\n\nOAuth 2.0 Google Sessions\n\n\nsource\n\n\n#\n\n\nGoogleCloud.session.GoogleSession\n \n \nType\n.\n\n\nGoogleSession(...)\n\n\nOAuth 2.0 session for Google using provided credentials.\n\n\nCaches authorisation tokens up to expiry.\n\n\nsess = GoogleSession(GoogleCredentials(expanduser(\n~/auth.json\n)), [\ndevstorage.full_control\n])\n\n\n\n\nsource\n\n\n#\n\n\nGoogleCloud.session.authorize\n \n \nMethod\n.\n\n\nauthorize(session[; cache=true)\n\n\n\n\nGet OAuth 2.0 authorisation token from Google.\n\n\nIf \ncache\n set to \ntrue\n, get a new token only if the existing token has not expired.\n\n\nsource\n\n\n#\n\n\nGoogleCloud.session.JWTClaimSet\n \n \nType\n.\n\n\nJWTClaimSet\n\n\n\n\nJSON Web Token claim-set.\n\n\nsource\n\n\n#\n\n\nGoogleCloud.session.JWTHeader\n \n \nType\n.\n\n\nJWTHeader\n\n\n\n\nJSON Web Token header.\n\n\nsource\n\n\n#\n\n\nGoogleCloud.session.JWS\n \n \nFunction\n.\n\n\nJWS(credentials, claimset)\n\n\n\n\nConstruct the Base64-encoded JSON Web Signature based on the JWT header, claimset and signed using the private key provided in the Google JSON service-account key.\n\n\nsource\n\n\n#\n\n\nGoogleCloud.session.SHA256withRSA\n \n \nMethod\n.\n\n\nSHA256withRSA(message, key)\n\n\n\n\nSign message using private key with RSASSA-PKCS1-V1_5-SIGN algorithm.\n\n\nsource\n\n\n#\n\n\nGoogleCloud.session.unixseconds\n \n \nMethod\n.\n\n\nunixseconds(x)\n\n\n\n\nConvert date-time into unix seconds.\n\n\nsource", 
            "title": "Sessions"
        }, 
        {
            "location": "/api/session/#google-api-authorisation-manager", 
            "text": "#  GoogleCloud.session     Module .  OAuth 2.0 Google Sessions  source  #  GoogleCloud.session.GoogleSession     Type .  GoogleSession(...)  OAuth 2.0 session for Google using provided credentials.  Caches authorisation tokens up to expiry.  sess = GoogleSession(GoogleCredentials(expanduser( ~/auth.json )), [ devstorage.full_control ])  source  #  GoogleCloud.session.authorize     Method .  authorize(session[; cache=true)  Get OAuth 2.0 authorisation token from Google.  If  cache  set to  true , get a new token only if the existing token has not expired.  source  #  GoogleCloud.session.JWTClaimSet     Type .  JWTClaimSet  JSON Web Token claim-set.  source  #  GoogleCloud.session.JWTHeader     Type .  JWTHeader  JSON Web Token header.  source  #  GoogleCloud.session.JWS     Function .  JWS(credentials, claimset)  Construct the Base64-encoded JSON Web Signature based on the JWT header, claimset and signed using the private key provided in the Google JSON service-account key.  source  #  GoogleCloud.session.SHA256withRSA     Method .  SHA256withRSA(message, key)  Sign message using private key with RSASSA-PKCS1-V1_5-SIGN algorithm.  source  #  GoogleCloud.session.unixseconds     Method .  unixseconds(x)  Convert date-time into unix seconds.  source", 
            "title": "Google API Authorisation Manager"
        }, 
        {
            "location": "/api/api/", 
            "text": "Google JSON APIs\n\n\n#\n\n\nGoogleCloud.api\n \n \nModule\n.\n\n\nGeneral framework for representing Google JSON APIs.\n\n\nsource\n\n\n#\n\n\nGoogleCloud.api.APIMethod\n \n \nType\n.\n\n\nAPIMethod(verb, path, description)\n\n\n\n\nMaps a method in the API to an HTTP verb and path.\n\n\nsource\n\n\n#\n\n\nGoogleCloud.api.APIResource\n \n \nType\n.\n\n\nAPIResource(path, methods)\n\n\n\n\nRepresents a resource in the API, typically rooted at a specific point in the REST hierarchy.\n\n\nsource\n\n\n#\n\n\nGoogleCloud.api.APIRoot\n \n \nType\n.\n\n\nAPIRoot(...)\n\n\n\n\nRepresent a Google JSON API containing resources, accessible via scopes.\n\n\nsource\n\n\n#\n\n\nGoogleCloud.api.get_session\n \n \nMethod\n.\n\n\nget_session(api)\n\n\n\n\nGet the default session (if any) for a specific API. Session is \nnothing\n if not set.\n\n\nsource\n\n\n#\n\n\nGoogleCloud.api.iserror\n \n \nMethod\n.\n\n\nCheck if response is/contains an error\n\n\nsource\n\n\n#\n\n\nGoogleCloud.api.set_session!\n \n \nMethod\n.\n\n\nset_session!(api, session)\n\n\n\n\nSet the default session for a specific API. Set session to \nnothing\n to forget session.\n\n\nsource\n\n\n#\n\n\nGoogleCloud.api.execute\n \n \nMethod\n.\n\n\nexecute(session::GoogleSession, resource::APIResource, method::APIMethod, path_args::AbstractString...[; ...])\n\n\n\n\nExecute a method against the provided path arguments.\n\n\nOptionally provide parameters and data (with optional MIME content-type).\n\n\nsource\n\n\n#\n\n\nGoogleCloud.api.path_replace\n \n \nMethod\n.\n\n\npath_replace(path, values)\n\n\n\n\nReplace path tokens in path with values.\n\n\nAssumes values are provided in the same order in which tokens appear in the path.\n\n\npath_replace(\n/{foo}/{bar}/{baz}\n, [\nthis\n, \nis\n, \nit\n])\n# output\n\n/this/is/it\n\n\n\n\n\nsource\n\n\n#\n\n\nGoogleCloud.api.path_tokens\n \n \nMethod\n.\n\n\npath_tokens(path)\n\n\n\n\nExtract tokens from a path, e.g.\n\n\npath_tokens(\n/{foo}/{bar}/x/{baz}\n)\n# output\n3-element Array{SubString{String},1}:\n \n{foo}\n\n \n{bar}\n\n \n{baz}\n\n\n\n\n\nsource\n\n\n\n\nImplemented APIs\n\n\n#\n\n\nGoogleCloud.api._storage\n \n \nModule\n.\n\n\nGoogle Cloud Storage API\n\n\nsource\n\n\n#\n\n\nGoogleCloud.api._storage.storage\n \n \nConstant\n.\n\n\nGoogle Cloud Storage API root.\n\n\nsource\n\n\n#\n\n\nGoogleCloud.api._compute\n \n \nModule\n.\n\n\nGoogle Compute Engine API\n\n\nsource\n\n\n#\n\n\nGoogleCloud.api._compute.compute\n \n \nConstant\n.\n\n\nGoogle Compute Engine API root.\n\n\nsource", 
            "title": "API Representation"
        }, 
        {
            "location": "/api/api/#google-json-apis", 
            "text": "#  GoogleCloud.api     Module .  General framework for representing Google JSON APIs.  source  #  GoogleCloud.api.APIMethod     Type .  APIMethod(verb, path, description)  Maps a method in the API to an HTTP verb and path.  source  #  GoogleCloud.api.APIResource     Type .  APIResource(path, methods)  Represents a resource in the API, typically rooted at a specific point in the REST hierarchy.  source  #  GoogleCloud.api.APIRoot     Type .  APIRoot(...)  Represent a Google JSON API containing resources, accessible via scopes.  source  #  GoogleCloud.api.get_session     Method .  get_session(api)  Get the default session (if any) for a specific API. Session is  nothing  if not set.  source  #  GoogleCloud.api.iserror     Method .  Check if response is/contains an error  source  #  GoogleCloud.api.set_session!     Method .  set_session!(api, session)  Set the default session for a specific API. Set session to  nothing  to forget session.  source  #  GoogleCloud.api.execute     Method .  execute(session::GoogleSession, resource::APIResource, method::APIMethod, path_args::AbstractString...[; ...])  Execute a method against the provided path arguments.  Optionally provide parameters and data (with optional MIME content-type).  source  #  GoogleCloud.api.path_replace     Method .  path_replace(path, values)  Replace path tokens in path with values.  Assumes values are provided in the same order in which tokens appear in the path.  path_replace( /{foo}/{bar}/{baz} , [ this ,  is ,  it ])\n# output /this/is/it   source  #  GoogleCloud.api.path_tokens     Method .  path_tokens(path)  Extract tokens from a path, e.g.  path_tokens( /{foo}/{bar}/x/{baz} )\n# output\n3-element Array{SubString{String},1}:\n  {foo} \n  {bar} \n  {baz}   source", 
            "title": "Google JSON APIs"
        }, 
        {
            "location": "/api/api/#implemented-apis", 
            "text": "#  GoogleCloud.api._storage     Module .  Google Cloud Storage API  source  #  GoogleCloud.api._storage.storage     Constant .  Google Cloud Storage API root.  source  #  GoogleCloud.api._compute     Module .  Google Compute Engine API  source  #  GoogleCloud.api._compute.compute     Constant .  Google Compute Engine API root.  source", 
            "title": "Implemented APIs"
        }, 
        {
            "location": "/api/root/", 
            "text": "Google API URLs\n\n\n#\n\n\nGoogleCloud.root\n \n \nModule\n.\n\n\nGoogle API URL roots.\n\n\nsource\n\n\n#\n\n\nGoogleCloud.root.isurl\n \n \nMethod\n.\n\n\nisurl(path)\n\n\n\n\nReturn true if \npath\n is a URL and false a path fragment.\n\n\nsource", 
            "title": "API Root URLs"
        }, 
        {
            "location": "/api/root/#google-api-urls", 
            "text": "#  GoogleCloud.root     Module .  Google API URL roots.  source  #  GoogleCloud.root.isurl     Method .  isurl(path)  Return true if  path  is a URL and false a path fragment.  source", 
            "title": "Google API URLs"
        }, 
        {
            "location": "/api/error/", 
            "text": "Error Types\n\n\n#\n\n\nGoogleCloud.error\n \n \nModule\n.\n\n\nBasic exceptions.\n\n\nsource\n\n\n#\n\n\nGoogleCloud.error.APIError\n \n \nType\n.\n\n\nAn error from the API.\n\n\nsource\n\n\n#\n\n\nGoogleCloud.error.CredentialError\n \n \nType\n.\n\n\nAn error in the provided credentials.\n\n\nsource\n\n\n#\n\n\nGoogleCloud.error.SessionError\n \n \nType\n.\n\n\nAn error in establising a session.\n\n\nsource\n\n\n#\n\n\nGoogleCloud.error.Error\n \n \nType\n.\n\n\nBase error type.\n\n\nsource", 
            "title": "Error Types"
        }, 
        {
            "location": "/api/error/#error-types", 
            "text": "#  GoogleCloud.error     Module .  Basic exceptions.  source  #  GoogleCloud.error.APIError     Type .  An error from the API.  source  #  GoogleCloud.error.CredentialError     Type .  An error in the provided credentials.  source  #  GoogleCloud.error.SessionError     Type .  An error in establising a session.  source  #  GoogleCloud.error.Error     Type .  Base error type.  source", 
            "title": "Error Types"
        }
    ]
}